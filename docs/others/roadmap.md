# Roadmap

There are a number of features that we could develop in order to make the smartr
account valuable to everyone. Below are some ideas that could be used as a
roadmap. We do **NOT** commit on those features, neither on any sort of timeline.

## Documentation

The project should have a number of documentation:

- Whitepapers about the account internals
- Reference documents for the components and helpers
- How-to guides and examples to develop modules
- How-to guides and examples to develop SDKs and/or Dapps
- Try to figure-out a solution so that the documentation is managed in the
  project.

## Validators

Validators are to be improved in a number of ways, In particular:

- check if we can move the validator decorator away from the call prefix
  into the signature
- make sure they are properly tested on sepolia and on the mainnet
- jail the sudo validator so that it can only be limited to account management
  tasks, including enabling/disabling the gardian

In addition there are a list feature that could be implemented as module
validators.

### Multisig Validators

Multisig Validators should be used both as a sudo and as a standard validator.
For now what we plan is a "all addresses are even" validator with a threshold.
It is working with the stark signature. What is plan is:
- Have validators that support P256 (secp256r1) to support passkeys and and
  ECDSA (secp256k1) to support ETH validators. We can assume that the hash have
  to also evolve in order to simplify the usage with the wallets.
- Force the use of a guardian validator in order to allow unlocking an account
  if, for instance, number of steps for \_\_validate\_\_ is too high and the
  account cannot be used (or could it be the core validator)

### Guardian Validator

Guardian can be requested to execute a limited number of things like:
- Helping for the recovery via a KYC process
- Managing the dead switch in case an event makes us think there is an issue
  with those wallets
- Prevent position liquidation if the market crashes

### Session Key Validator

Session keys grant some limited accesses to a signer. We can see it as "grant
a set of limited accesses to a signer (i.e a public key) instead of execute a
transaction with a contract (secured by a public key)". For now, session key
grants are offchain, limited to a set of calls (the policies) within a period
of time. We should evolve the model so that:

- the session key itself is provided by a multiple set of signatures, one
  being for instance a 3rd party service that would block session key issuance.
  Another scenario for this requirement is that the account is a multisig with
  a threshold that is 2 or more.
- the session key not only limits the call contract address and selector but
  also the calldata to be used. This would allow to limit the amount of an
  ERC20 `approve` per execution for instance.
- the number of executions authorized with a key is limited. That would require
  the execution are tracked in the storage of the account or a 3rd party
  contract.
- there is an allowance ceiling on a specific ERC20. Every `ERC20.approve` would
  then be tracked in the storage for that key. It would allow defi scenarios
- the session key would require some hardcoded prefix calls so that the key
  force the use of a set of execution validators. For instance, do a transaction
  but first, make sure some conditions are met
- the session key would require some hardcoded suffixes calls so that the key
  force the result of an execution through an execution validators. For
  instance, do a transaction at the end, make sure that there is still some
  supply
- the session key manages a set of user defined nonces
- it supports other signature schemes to work with passkeys or eth

> Note: An interesting scenario to explore is could we do something with a
> multicall generated by a signer that would have been granted multiple session
> keys for the same account ?

### Transaction Grant Validator

A Transaction Grant is a a middle ground between signing a transaction
and signing a signer (aka the session key). The idea is to introduce a signature
that would be based on something that does not have the regular account nonce
in it but some other nonce managed by the protocol. That would be the module
that would manage the fact that the nonce has been used to prevent transaction
replay more than N-times. Assuming we could group those transactions in a simple
call, then this validator could also (1) reduce the price of the execution and
(2) provide multiplexer (or should we call it a sequencer) so that all those
transactions could be grouped in the same block without the risk of a failure
because the order of execution is not the same has the one of the getNonce()
call. Obviously that would require the user managed nonce is randomized

- this validator enables to sign a transaction without the nonce, so that it can
  be executed several times, assuming the validator is enabled on the account.
- an addition to it consists in limiting the number of executions associated 
  with it so that the transaction can be executed, N-times only. To address that
  we would generate the nonce from the transaction hash and add a counter inside
  the contract
- N-of-M; as an evolution of this validator, we would define M transaction and
  generate a Merkle tree of them, passing the root to the validator with the
  TX Grant proof. We would track the number of execution, allowing to run N of
  M transactions. A use case is to allow a 3rd party to swap on an account but
  force it to only do it once letting him choose between several protocols.
- Another control could be to block a period of time between 2 executions.
- In addition to the nonce, we could add a condition to grant access to the
  transaction like, for instance, the result of an Oracle, a VRF or the result
  of a vote.

> Note: For security reasons, we would strongly encourage to use an `expires`
> attribute and to rely on a separate service to keep track of those "granted"

### P256 and Passkeys/WebAuthn:

secp256r1, with a **r** is the signature validated by the NIST and the basis for
a number of protocols including TLS, DNSSEC, Apple's Secure Enclave, Passkeys,
Android Keystore or Yubikey. Starknet supports with v0.12.3 secp256r1 as part of
[Starknet OS](https://community.starknet.io/t/starknet-next-versions-v0-12-3-v0-13-0-and-sepolia-testnet-migration/106529)
We have created a
[PR/branch on OpenZeppelin/cairo-contracts](https://github.com/OpenZeppelin/cairo-contracts/pull/988)
so that OpenZeppelin provides the tools to implement P-256 and we have created
a P256 Validator that relies on the associated signature.

We have investigated the issue and review the existing solution from Cartridge
as well as how to implement it in website. Some very useful resources are:
- [The passkeys playground](https://learnpasskeys.io/demo/create)
- [The WebAuthn Tutorial](https://webauthn.me/)
- [This blog about Webauthn and Passkeys](https://webauthn.me/passkeys)
- [This Passkey debugger](https://webauthn.me/debugger)
- [The Web Authentication API on MDN](https://developer.mozilla.org/en-US/docs/Web/API/Web_Authentication_API)
- [WebAuthn Chrome Web Developer Codelabs](https://developers.google.com/codelabs/webauthn-reauth)

We could develop a passkeys signer even if it has some drawbacks and would
prevent it from being used as a Core Signer. That is because
- The passkey depends on a Rely Party (RP) that is a domain and as such, your
  ability to sign from your phone depends on a 3rd party or the fact that you
  manage a domain
- In addition, the signature check probably requires we can check the content of
  a token and the associated fields, like the challenge key this is in the
  signed text. As a result, it would rely on some text or json parser that
  should be in the contract.
- The conditions are not easy to validate; the spec is quite hard and it would
  for sure require some specialist/audit
- Last but not least, the cost (gas) of the P256 signature and the number of
  instruction that would require to be run in the `__validate__` part of the
  contract might be an issue

Our position on the matter and, unless there is an opportunity for a Dapp for
instance is probably to wait on the matter.

### Other Validators

There are a number of validators to consider, including:

- the yasager validator with merkle root that specifies a fix transaction set.
  for instance it would enable to run a transaction paid by a 3rd party that
  would check some condition like the ownership of an NFT to send some tokens.
  It could be used as a faucet or a rewarding contract.

You should also check hackathons and ideas popping around, including:

- The ability to activate a module Offchain from a session key, see
  [Why we are building Kernel on ERC-7579](https://docs.zerodev.app/blog/why-7579-over-6900)
  in the Zerodev.app.
- The use of ZK Verifier trigger a call if something is proven. I'm wondering if
  it could help with Privacy to avoid showing-up addresses or more simply
  building some kind of mixer.
- The use of other verification techniques like the
  [time/place of a photo](https://www.tdcommons.org/cgi/viewcontent.cgi?article=5433&context=dpubs_series)
  as well as the result of an AI-classification of the photo.
- The ability to integrate offchain services to access the account. They could
  be centralize with the addition of a limited access to the account via a key.
  They could also be part of a composition, i.e. they could co-sign or sign a
  certain set of arguments in the call. They could have been granted some sort
  of pre-agreement onchain (via an ID) or even offchain with a sessionkey. A
  good example is that an external service chooses the address of the swap
  protocol to use to optimize fees
- The ability to use the same transaction on several chain for a global
  transaction. This requires relying on an Internal Nonce and filtering the call
  based on the chainid. A close scenario consists in signing the L2 transaction
  with a L1 wallet.
- Basing realworld operation on a wallet transaction. Not sure if it makes sense
  right scenario and what the challenge but a hackathon project has opened a
  house door base on the fact people can run a Tx on a Safe
- The addition of some specific requirements, like the fact that the
  service/person that gets the fund sign the transaction to prove he has the key
  to release fund and avoid we send data into the ether
- The creation of a safe switch that can be triggered by a third party that can
  act as a guardian for certain transactions but also freeze the account in
  case of an emergency.
- Use a custodial guardian to change keys based on an email. Coupled with a
  web signer, this enable the design of a web solution.
- Prebuilt modules for DAOs
- Starknet implement other schemes like secp256k1. the Ethereum Elliptic Curve
Cryptography. It is already possible, with the OpenZeppelin account, to sign
transactions with a key from an Ethereum Signers. We could leverage this feature
and possibly others in the future.

## Executors

Scenarios of executors are yet to be better defined. However, there is a number
of solutions that can be provided with this system, including:

- agree now to execute later (store with a hash and key and emit an event), 
  except if some blocage is performed. Allow to run later transaction with a
  model with an incentive for triggering bots
- onchain multi-signature

## Signers

Signers is probably the most obvious extension for such an account. There are
several things to experiment in there including:

- a chrome/firefox extension
- a mobile app that could rely on the phone enclave key
- a web signer that could be guarded by a centralized service the same way the
  web account from Argent web account works

Instead of signing transaction, the signers should focus on signing external
messages in a way that is close to the EIP-712 for 

## Dapps and SDKs

- an application that can be used to manage your account. It could also manage
  reminders so that people renew authorizations
- a chrome/firefox signer that would allow a multisig coordination to manage
  the account
- a stop/loss application that relies on the session key managed by a bot
- integrate the account/signer with starknetkit

## Registry and "reviewed" Modules

provide a validation process for a modular model. Check if we can rely on
manager/registry/interfaces like [Safe{Core} Protocol](https://forum.safe.global/t/safe-core-protocol-whitepaper/3949) does or on something like
[EIP-7484](https://eips.ethereum.org/EIPS/eip-7484).

Assuming we can call a library from the __validate__ entrypoint, we propose the following:
- the list of validator modules should be managed in a library so that it can be checked at execution time
- we should have a contract with the expired validator so that the lib does not change, we can blacklist a validator. In that case, it would be executed in the __execute__

## Bootstrapper

Check if that is possible to use an account to bootstrap another account class.
One possible scenario would be that the core validator address would be
hardcoded in the bootstraping contract and the final account would get it from
a setup in the storage from it.

## Other ideas

- monitor the number of steps used in various \_\_validate\_\_ scenarios
- present the project to starkware and/or be involved with hackathons. Also
  build a community to support the project and get help
- [QR code for transaction encoding](https://community.starknet.io/t/qrcode-starknet-transaction-encoding/113885/3)
- the __validate_deploy__ and __validate_declare__ use the is_valid_signature
  method of the core module with a transaction_hash computed by the network.
  This might have to be revisited or not. As a matter of fact, addresses of the
  account and contract are based on the pedersen hash anyway so why not simply
  sign those. A hunch is that somehow the pedersen hash is useful in that case.
