# Using the Multisig Validator

When installed with the Multisig Validator Module, the starknet modular account
not only can have multiple signers registered but it can also require N of those
signers to agree to sign a transaction. This Multisig feature takes place
offchain and the `SmartrAccount` class provides the framework manage several
signers on the same account to sign the a transaction. This is what is shown in
this section.

- [Using the Multisig Validator](#using-the-multisig-validator)
  - [Interacting with the Multisig Validator](#interacting-with-the-multisig-validator)
    - [Getting the stark validator module class hash](#getting-the-stark-validator-module-class-hash)
    - [Check the module is installed on the account](#check-the-module-is-installed-on-the-account)
    - [Calling views functions in the module](#calling-views-functions-in-the-module)
    - [Executing external functions in the module](#executing-external-functions-in-the-module)
  - [Interacting with a Contract with the new registered key](#interacting-with-a-contract-with-the-new-registered-key)
  - [Changing the Account Threshold to 2](#changing-the-account-threshold-to-2)
  - [Checking you can **NOT** run a transaction with a single signer](#checking-you-can-not-run-a-transaction-with-a-single-signer)
  - [Running a Multiple Signer Transaction](#running-a-multiple-signer-transaction)
  - [Reset the threshold to one](#reset-the-threshold-to-one)
  - [Remove Registered Keys](#remove-registered-keys)

> Note 1: This section assumes the `SmartrAccount` class has been instantiated
> in the `smartrAccount` variable as shown in
> [Using the modular account from the SDK](./SDKS-DEPLOYMENT.md#using-the-modular-account-from-the-sdk).
> It also assumes the `Counter` contract that comes with the project has been
> deploys to the `counterAddress` and the `CounterABI` class are available. The
> `03-setup.ts` script that comes with this project ensure those steps are
> executed.

> Note 2: This multi-signer model has some limits: the exchange of the
> transaction between signers is not managed by the SDK and requires some
> synchronization between the actors. In addition, the fact the transaction is
> a regular transaction that involves the account Nonce generated by the network
> prevents from using it at a large scale. The starknet modular account can
> be used to implement more advanced models to workaround those 2 issues.


## Interacting with the Multisig Validator

The `SmartrAccount` class, however, provides more than just the regular
`Account` class. It can interact with functions that are part of the module
and not part of the account. In the case of the Multisig Validator, those
functions are:

```rust
fn get_public_keys(self: @TState) -> Array<felt252>;
fn add_public_key(ref self: TState, new_public_key: felt252);
fn remove_public_key(ref self: TState, old_public_key: felt252);
fn get_threshold(self: @TState) -> u8;
fn set_threshold(ref self: TState, new_threshold: u8);
```

To execute a function that is part of the module you need:

- to figure out the Multisig Validator module class hash
- to check the module is installed on the account. That is something that is
  setup at the account deployment time
- to use one of `callOnModule` for view functions or `executeOnModule` for
  running transactions on the SmartrAccount.

The sections below dig into the details of these operations.

### Getting the stark validator module class hash

This is something we have already done previously. You can use
`classHash("MultisigValidator")` after your imported the `classHash` function
from `@0xknwn/starknet-module` like below:

```typescript
{{#include ../experiments/documentation-examples/src/03-check-class.ts}}
```

To execute the script, make sure you have deployed the account in the network
and run the following commands:

```shell
npx tsc --build

node dist/03-check-class.js
```

### Check the module is installed on the account

The `SmartrAccount` provides a method `isModule` that can be used to know if
a module is installed with the account. 


```typescript
{{#include ../experiments/documentation-examples/src/03-module-installed.ts}}
```

Transpile and run the script:

```shell
npx tsc --build

node dist/03-module-installed.js
```

### Calling views functions in the module

To execute a view function on the module, we must build the argumemt list with
the `CallData` class. Thwn we can call the `callOnModule` function from
`SmartrAccount` with the module class hash, the function name and the calldata
like below:

```typescript
{{#include ../experiments/documentation-examples/src/03-registered-publickeys.ts}}
```

Transpile and run the script:

```shell
npx tsc --build

node dist/03-registered-publickeys.js
```

### Executing external functions in the module

To execute an external function on the module, we must build the argumemt list
with the `CallData` class. Then we can call the `executeOnModule` function from
`SmartrAccount` with the module class hash, the function name and the calldata
like below. Here we will register a second public key for the same account:

```typescript
{{#include ../experiments/documentation-examples/src/03-add-publickeys.ts}}
```

Transpile and run the script:

```shell
npx tsc --build

node dist/03-add-publickeys.js
```

You can re-run the script from the previous example to check the account has
two registered public key:

```shell
node dist/03-registered-publickeys.js
```

The output should look like that:

```text
number of public keys for module 3
publickey # 1 0x1ef15c18599971b7beced415a40f0c7deacfd9b0d1819e03d723d8bc943cfca
publickey # 2 0x759ca09377679ecd535a81e83039658bf40959283187c654c5416f439403cf5
publickey # 3 0x411494b501a98abd8262b0da1351e17899a0c4ef23dd2f96fec5ba847310b20
```

## Interacting with a Contract with the new registered key

You now can interact with the `SmartrAccount` with your second private key like
below:

```typescript
{{#include ../experiments/documentation-examples/src/03-execute-tx-pk2.ts}}
```

Transpile and run the script:

```shell
npx tsc --build

node dist/03-execute-tx-pk2.js
```

## Changing the Account Threshold to 2

By changing the Multisig Validator Threshold to 2, you force transactions to be
signed by 2 of the 3 signers of the account. Run a script like below to
change the threshold:

```typescript
{{#include ../experiments/documentation-examples/src/03-increase-threshold.ts}}
```

Transpile and run the script:

```shell
npx tsc --build

node dist/03-increase-threshold.js
```

You can check the current threshold on the account with the script below:

```typescript
{{#include ../experiments/documentation-examples/src/03-get-threshold.ts}}
```

Run the script with the command below:

```shell
npx tsc --build

node dist/03-get-threshold.js
```

## Checking you can **NOT** run a transaction with a single signer

The script below executes a transaction with a single signer as it was the case
in the previous section:

```typescript
{{#include ../experiments/documentation-examples/src/03-execute-tx.ts}}
```

Make sure you have deployed the account and the counter contract in the network
and run the following commands:

```shell
npx tsc --build

node dist/03-execute-tx.js
```

You are now getting an error saying the signature is invalid like below:

```output
Execution failed.
Failure reason: 0x4163636f756e743a20696e76616c6964207369676e6174757265 
('Account: invalid signature')
```

## Running a Multiple Signer Transaction

To run a transaction with multiple signers, you need to instantiate several
`SmartrAccount`, each one with a different signer. Because you have set the
threshold, you need to instantiate 2 accounts.

Once done, proceed in 3 steps:

- Step 1: generate the transaction details. This requires you create the calls
  but also you set some details about it, including: the Fees, the Nonce, the
  Version and the Chain. The `SmartrAccount` class uses the provider to
  get the chain id. To get the other details, you should run the
  `prepareMultisig` that returns the details associated with the transaction.
- Step 2: have all the signers generate their part of the signature. The
  `signMultisig` takes the list of calls and the details you have generated and
  provides the signature as an array of string
- Step 3: Execute the transaction with all the signatures from Step 2. This
  could be done by anyone, including one of the account you have already
  created. The `executeMultisig` function takes the list of calls, the details
  and an array that contains all the signatures.

The script below signs the transaction with 2 signers and to run the `increment`
external function of the `Counter` contract. It shows the value of the counter
before and after the call:

```typescript
{{#include ../experiments/documentation-examples/src/03-execute-tx-multiple-signers.ts}}
```

Transpile and run the script:

```shell
npx tsc --build

node dist/03-execute-tx-multiple-signers.js
```

## Reset the threshold to one

As for any transaction, you need to run a multi-signed transaction to reset the
account threshold back to one. The script below build the call to
`execute_on_module` and run it with multiple signer:

```typescript
{{#include ../experiments/documentation-examples/src/03-decrease-threshold.ts}}
```

Execute the script with the following commands:

```shell
npx tsc --build

node dist/03-decrease-threshold.js
```

You can check the threshold is back to one:

```shell
node dist/03-get-threshold.js
```

## Remove Registered Keys

You can now run transaction with a single signer on the account. The script
below shows how to remove 2 public keys from a single call:

```typescript
{{#include ../experiments/documentation-examples/src/03-remove-publickeys.ts}}
```

Transpile and run the script:

```shell
npx tsc --build

node dist/03-remove-publickeys.js
```

You can check the 2 of the 3 public keys have been removed:

```shell
node dist/03-registered-publickeys.js
```
